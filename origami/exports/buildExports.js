/** @typedef {import("@weborigami/types").AsyncTree} AsyncTree */
import { keyFunctionsForExtensions, map } from "@weborigami/async-tree";
import fileTypeOrigami from "../src/builtins/ori_handler.js";
import { transformObject } from "../src/common/utilities.js";
import PathTransform from "./PathTransform.js";

// For builtins that should be renamed or not exported
const specialBuiltinNames = {
  constructor: null,
  false: null,
  true: null,
};

// Top-level template for the export file
const templateText = `=\`// This file is generated by running buildExports.js -- do not edit by hand.
\${ _ }\``;

// Generate a top-level export file for the entire project. For each .js file in
// the given source tree, generate an appropriate statement that includes that
// file's export(s) in the top-level export file.
export default async function exportFile(src) {
  const statements = await exportStatements(src);
  const templateFn = await fileTypeOrigami.unpack(templateText);
  const result = await templateFn(statements);
  return result;
}

/**
 * Given a buffer containing the code for a JavaScript file, generate an
 * appropriate export statement for that file.
 *
 * @this {AsyncTree}
 */
async function exportStatementForCode(codeBuffer, key) {
  const code = String(codeBuffer);

  const exportsAnything = code.match(/^export /m);
  if (!exportsAnything) {
    // Has no exports
    return "";
  }

  // @ts-ignore
  const path = codeBuffer[PathTransform.pathKey] ?? "";

  const exportsDefault =
    code.match(/^export default /m) || code.match(/^export { default } /m);
  if (!exportsDefault) {
    // Export everything.
    return `export * from "../src/${path}";\n`;
  }

  // Single export

  // We construct an identifier for the export based on the path to the file and
  // the file name. This omits the first part of the path, which is the name of
  // a folder that's a direct child of the `src` folder. We omit the `.js`
  // extension, and remove any characters that aren't valid in JS identifiers.
  // We use camelCase to combine the parts. As an example, the file inside the
  // src folder at `builtins/@image/format.js` will be identified as
  // `imageFormat`.

  // Split the name into parts wherever there are characters that can't be in
  // JavaScript identifiers; drop any empty parts.
  const parts = path.split(/[^a-zA-Z0-9]/g).filter(Boolean);

  // Drop the first (folder) part and the last (`.js`) part.
  parts.shift();
  parts.pop();

  // Join the parts in camelCase to form the identifier.
  let identifier = parts
    .map((part, index) =>
      index === 0 ? part : part[0].toUpperCase() + part.slice(1)
    )
    .join("");

  if (!identifier) {
    // Name is entirely non-JS characters, like `~`. For now we ignore it.
    return "";
  }

  // Ignore certain builtins like `@true` and `@false` that would conflict with
  // JavaScript keywords. Developers can use those JavaScript keywords directly.
  const specialName = specialBuiltinNames[identifier];
  if (specialName === null) {
    return "";
  }
  if (specialName) {
    identifier = specialName;
  }

  return `export { default as ${identifier} } from "../src/${path}";\n`;
}

function exportStatements(src) {
  // Add paths to the source tree so they can be used in the export statements.
  const withPaths = transformObject(PathTransform, src);

  // Map each source file to an export statement.
  const mapped = map(withPaths, {
    deep: true,
    value: exportStatementForCode,
    ...keyFunctionsForExtensions({ sourceExtension: "js" }),
  });

  return mapped;
}
