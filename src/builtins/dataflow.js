import path from "path";
import builtins from "../cli/builtins.js";
import ExplorableGraph from "../core/ExplorableGraph.js";
import { transformObject } from "../core/utilities.js";
import MetaTransform from "../framework/MetaTransform.js";
import * as ops from "../language/ops.js";
import CommandsModulesTransform from "../node/CommandModulesTransform.js";

const commands = transformObject(CommandsModulesTransform, builtins);

const ignoreKeys = await ExplorableGraph.keys(commands);
ignoreKeys.push(".");
ignoreKeys.push("..");
ignoreKeys.push(ops.thisKey);

export default async function dataflow(variant) {
  let graph = ExplorableGraph.from(variant);
  if (!("formulas" in graph)) {
    graph = transformObject(MetaTransform, graph);
  }

  const flow = {};
  const formulas = await /** @type {any} */ (graph).formulas();
  await addFormulaDependencies(flow, formulas);

  const formulaKeys = formulas.map((formula) => formula.key);
  await addContentDependencies(flow, graph, formulaKeys);

  return flow;
}

async function addContentDependencies(flow, graph, formulaKeys) {
  for await (const key of graph) {
    if (formulaKeys.includes(key)) {
      // Skip keys generated by formulas.
      continue;
    }
    const extension = path.extname(key);
    const dependencyParsers = {
      ".html": htmlDependencies,
      ".ori": origamiTemplateDependencies,
    };
    const parser = dependencyParsers[extension];
    if (parser) {
      const value = await graph.get(key);
      const dependencies = await parser(value);
      updateFlowRecord(flow, key, { dependencies });

      // Also add the dependencies as nodes in the dataflow.
      dependencies.forEach((dependency) => {
        updateFlowRecord(flow, dependency, {});
      });
    }
  }
}

async function addFormulaDependencies(flow, formulas) {
  for (const formula of formulas) {
    const { key, expression, source } = formula;
    const dependencies = expression ? codeDependencies(expression) : null;

    if (dependencies?.length === 0) {
      // All dependencies are builtins.
      // Use the RHS of the formula as the dependency.
      const parts = source.split("=");
      const rhs = parts[parts.length - 1]?.trim();
      if (rhs) {
        updateFlowRecord(flow, key, {
          dependencies: [source],
        });
        updateFlowRecord(flow, source, {
          label: rhs,
        });
      } else {
        // Formula is not an assignment.
      }
    } else if (dependencies) {
      // We have at least some dependencies on other values in the graph (not
      // builtins).
      updateFlowRecord(flow, key, { dependencies });

      // Also add the dependencies as nodes in the dataflow.
      dependencies.forEach((dependency) => {
        updateFlowRecord(flow, dependency, {});
      });
    }
  }
}

function codeDependencies(code) {
  if (code instanceof Array) {
    if (code[0] === ops.scope) {
      const key = code[1];
      return ignoreKey(key) ? [] : [key];
    } else {
      return code.flatMap((instruction) => codeDependencies(instruction));
    }
  } else {
    return [];
  }
}

function ignoreKey(key) {
  // HACK: instead of `instanceof Array` to catch ops.thisKey,
  // have parser stop wrapping ops.thisKey in an array.
  if (key instanceof Array) {
    return true;
  } else if (key.startsWith("@")) {
    return true;
  }
  if (!ignoreKeys) {
  }
  return ignoreKeys.includes(key);
}

async function htmlDependencies(html) {
  // HACK: Use a regex to find img src attributes.
  // TODO: Use a real HTML parser.
  const imgSrcRegex = /<img[\s\S]+?src="(?<src>.+)"[\s\S]+?\/?>/g;
  const matches = [...html.matchAll(imgSrcRegex)];
  const srcs = matches.map((match) => match.groups.src);

  // Take first part of the src path that isn't a "." or "..".
  const pathHeads = srcs.map((src) => {
    const parts = src.split("/");
    if (parts.length === 0) {
      return src;
    }
    while (parts[0] === "." || parts[0] === "..") {
      parts.shift();
    }
    return parts[0];
  });

  return pathHeads;
}

async function origamiTemplateDependencies(template) {
  let dependencies = [];
  if (!template.code) {
    await template.compile();
    dependencies = codeDependencies(template.code);
  }

  // If the template appears to contain HTML, add the HTML dependencies.
  // HACK: Crude heuristic just sees if the first non-space is a "<".
  if (template.text.trim().startsWith("<")) {
    dependencies = dependencies.concat(await htmlDependencies(template.text));
  }

  return dependencies;
}

function updateFlowRecord(flow, key, record) {
  const existingRecord = flow[key];

  if (!existingRecord) {
    flow[key] = record;
  }

  // Merge and de-dupe dependencies.
  const oldDependencies = existingRecord?.dependencies ?? [];
  const newDependencies = record?.dependencies ?? [];
  const set = new Set([...oldDependencies, ...newDependencies]);
  const unique = [...set];
  if (unique.length > 0) {
    flow[key].dependencies = unique;
  }
}
